# *DODONA 复现开发日志

| 时间       | 进行任务                                             | 后续任务                              |
| ---------- | ---------------------------------------------------- | ------------------------------------- |
| 2021-11-4  | 写完OS-LAB，创建了这个文档，开始读文献，提取主要工作 | 了解JPF的使用、安装并能成功读取字节码 |
| 2021-11-9  | 安装了JPF                                            | 阅读使用JPF搭建测试环境的论文         |
| 2021-11-18 | 放弃                                                 |                                       |

[TOC]

------

11月4日更新:disappointed: <del>感觉作业要写不完</del>

## 主要工作（顺序）

- JPF的使用
- 算法一的实现
- JUNG的使用
- 算法二的实现
- 评估（能实现前面的就不错了）

## DODONA论文要点

> DODONA并不是要完全自动化测试预言生成。而是支持测试工程师构建**期望值测试预言**，即为一个测试输入指定一个或多个程序值的具体期望值的预言

### DODONA概述

DODONA的运行基于三个假设

- 程序变量中的错误值在程序执行期间得到传播和进一步使用（包括直接使用和传递）
- 受到许多其他变量影响的变量会比其他变量更可能包含错误值
- 随着中间计算次数的增加，错误值传递到变量的可能性降低

因此，有效的测试预言数据集应该由一小部分变量组成，这些变量在计算上和其他变量高度相关

![](.\pics\QQ截图20211104202358.png)

上图即Dodona使用方法图：

- 首先使用*数据流分析和网络中心技术*，为每个测试输入构建程序变量网络。[参见算法一](#可变关系网络的构建)
- 接下来，使用网络中心度量来根据相关性或结果网络中心性对变量进行排序[参见算法二](#算法二：网络中心度量算法)

**在上述算法中，都采取步骤确保Oracle数据集是根据可观察点构造的**

### 可变关系网络的构建

给定一个测试用例t和程序p。使用本算法来映射从t中的输入数据到p中所有潜在观察点的信息。

这是通过执行t，跟踪t的输入中的数据流，通过中间变量-符号和对对象中成员变量的方法调用来实现的。

在跟踪数据时，要注意考虑变量的上下文，包括变量作用域和用于到达变量的方法调用。这些信息稍后会用于确定如何观察变量。

> 例如：考虑`int c = a + b`，在这里，c使用操作数a和b初始化，导致了a和b与c之间的单向关系。我们将其称之为c<-a，和c<-b。当c被添加到邻接矩阵时，它的动态范围作为方法调用的一部分也会被捕获（和方法调用的参数一起）。

由于每条指令都是顺序执行的，所以网络是以每个关系作为一个新的边来构建的。在测试用例的执行结束时，该算法在adjMat中生成一个不对称的邻接矩阵，以及每个变量到引用该变量的方法调用的映射

**Dodona的动态数据分析是基于JPF监听器实现的**，当运行JAVA测试时，Dodona监视字节码的所有执行，这些执行将导致分配一个值、方法调用和方法返回。当执行任何一个赋值时，Dodona相应的扩展和更新JAVA邻接矩阵、跟踪操作数和赋值变量的关系，并记录范围。当前方法调用以及赋值对应的源代码变量

数组 (例如)由多个变量组成; 数组中的每个元素都有一个变量。当一个方法调用发生时，Dodona 跟踪从当前方法中用作方法参数的变量到被调用方法的信息。注意，通过在字节码级别构造邻接矩阵，Dodona 避免了潜在的 麻烦问题，例如，方法调用作为操作数，例如，在编译期间， x = a + somethod (b) | ，这些操作被简化为向临时变量赋值。

### 根据相关性排序

Dodona在选择变量时的目标是“覆盖所有变量”，即确保所有计算值传播到测试预言，并尽量使用最少数量的中间计算。然而，我们经常需要在覆盖以前发现的变量和减少变量中间计算数量之间做出折中。





#### 算法二：网络中心度量算法

常用于1分析图中节点的相对重要性，并经常用于社会网络的分析。

对图中所有点计算器中心度。主要有以下几种度量方法

- 度中心：节点的入度、出度个数
- 紧密中心：将节点n-g与g中所有其他节点距离和的倒数定义为节点n2g与g中所有其他节点的距离之和
- 中间性中心：节点 n2g 之间的间隔 是在任意两个节点 n1; n22g 之间行走最短路径时 n 必须遍历的频率。变量 v 的高分表示 v 通常存储中间计算
- 特征向量中心：类似网站权重算法

网络中心度量使用开源库**JUNG**框架





在进行过网络中心度量后，将具有中心性得分的变量列表进行转换和映射，只保留那些公共变量和具有公共范围的变量。即由公共方法调用引用的变量。

公共方法调用引用的变量被映射到适当的方法调用(通常是 get 方法)。最后，Dodona 通过降序中心得分对映射列表进行排序。

#### 将变量映射到可观测点

在应用中心度量之后，Dodona 必须将每个变量映射到一个可观测点，然后输出所有不能映射的变量。这是使用数据分 析期间记录的信息来完成的。Public 变量不需要被映射，它们可以直接被引用为 object.variable。对于每个非公共变量， Dodona 首先检查变量所在的方法调用是否是公共的。如果是公共的，这个方法调用当变量被观察到时使用的参数。如果变量在公共方法调用中没有被观察到，那么它就被认为是不可观察的，Dodona将其从排名中删除。

### 测试oracle的构建

Dodona 为每个测试输入生成一个可观察点的列表，根据网络中心度量的重要性排序。为了构建一个oracle数据集，测试工程师从排名列表中选择前n个可观察点，其中 n 个由工程师根据他或她认为有必要的努力程度确定。工程师然后构建一个完整的测试预言，通过确定预言数据集中每个元素的预期值，并将它们放在测试输入之后。在 ju-unit 测试中，工程师将为每个变量构造assertEquals调用，断言该变量具有他或她所期望的给定测试输入的值。

------

11月9日更新 :happy:

## 实现过程

### JPF安装

#### 源码下载

https://github.com/javapathfinder/jpf-core

> 在一些网站上也能找到曾经的二进制镜像，但是不确定能不能使用。

#### 构建

过程比较折磨，报了很多错。JDK从8-13换了个遍。:crying_cat_face:

最后在issue里面发现了同样的问题：https://github.com/javapathfinder/jpf-core/issues/276

更换为OpenJDK 1.8_321后成功

不得不佩服。竟然官方JDK不如Open JDK

------

在安装了合适的JDK后，运行gradlew.bat脚本，成功运行。

### 阅读Model Checking Programs（引文24：阐述了如何实现JPF测试环境）

找到了原文：[Model Checking Programs (springer.com)](https://link.springer.com/content/pdf/10.1023/A:1022920129859.pdf)

------

11月10日更新 :weary:

这是一篇关于JPF的论文，对本工具没有什么帮助

### JPF运行

今天成功使用命令行将JPF运行起来了。但是如何

